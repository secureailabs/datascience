<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sail_safe_functions.aggregator.preprocessing.query API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sail_safe_functions.aggregator.preprocessing.query</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import ast
import io
import os
import sys
from typing import Any, List

import numpy as np
import pandas as pd
from pandas.core.computation.expr import Expr, Scope
from sail_safe_functions.aggregator.data_frame_federated import DataFrameFederated
from sail_safe_functions.aggregator.tools_common import check_instance
from sail_safe_functions.aggregator.tools_specific.parser import unparse
from sail_safe_functions.participant.preprocessing.query_precompute import QueryPrecompute


def query(
    data_frame_source: DataFrameFederated,
    query_expression: str,
    parser: str = &#34;pandas&#34;,
    local_dict: dict = None,
    global_dict: dict = None,
) -&gt; DataFrameFederated:
    &#34;&#34;&#34;
    Federated equivalent of (pd.DataFrame.query)
    &#34;&#34;&#34;
    return Query.run(data_frame_source, query_expression, parser, local_dict, global_dict)


class Query:
    &#34;&#34;&#34;
    Federated equivalent of (pd.DataFrame.query)
    &#34;&#34;&#34;

    @staticmethod
    def run(
        data_frame_source: DataFrameFederated,
        query_expression: str,
        parser: str,
        local_dict: dict,
        global_dict: dict,
    ) -&gt; DataFrameFederated:
        &#34;&#34;&#34;
        Perform federated query (pandas.DataFrame.query) function

        :param data_frame_source: The target DataFrame
        :type data_frame_source: DataFrameFederated
        :param query_expression: The query string to evaluate. You can refer to variables in the environment by prefixing them with an ‘@’ character like @a + b. You can refer to column names that are not valid Python variable names by surrounding them in backticks. Thus, column names containing spaces or punctuations (besides underscores) or starting with digits must be surrounded by backticks. (For example, a column named “Area (cm^2)” would be referenced as `Area (cm^2)`). Column names which are Python keywords (like “list”, “for”, “import”, etc) cannot be used. For example, if one of your columns is called a a and you want to sum it with b, your query should be `a a` + b.
        :type query_expression: str
        :param parser: The parser to use to construct the syntax tree from the expression. The default of &#39;pandas&#39; parses code slightly different than standard Python. Alternatively, you can parse an expression using the &#39;python&#39; parser to retain strict Python semantics. See the https://pandas.pydata.org/docs/user_guide/enhancingperf.html#enhancingperf-eval documentation for more details.
        :type parser: str
        :param local_dict: A dictionary of local variables, taken from locals() by default.
        :type local_dict: dict
        :param global_dict: A dictionary of global variables, taken from globals() by default.
        :type global_dict: dict
        :return: Federated DataFrame resulting from the provided query expression.
        :rtype: DataFrameFederated
        &#34;&#34;&#34;
        check_instance(data_frame_source, DataFrameFederated)
        check_instance(query_expression, str)
        check_instance(parser, str)
        check_instance(local_dict, (dict, type(None)))
        check_instance(global_dict, (dict, type(None)))

        caller_frame = sys._getframe(2)
        local_dict = local_dict if local_dict else caller_frame.f_locals
        global_dict = global_dict if global_dict else caller_frame.f_globals

        validated_query = Query.validate_query(
            query_expression,
            parser,
        )
        validated_local_dict, validated_global_dict = Query._validate_envs(local_dict, global_dict)

        list_reference = data_frame_source.map_function(
            QueryPrecompute,
            validated_query,
            parser,
            validated_local_dict,
            validated_global_dict,
        )

        return DataFrameFederated(list_reference, data_frame_source.data_model_data_frame)

    # Target dataframe will be allowed even if pd.DataFrame is not included here
    _allowed_var_types = frozenset(
        [
            str,
            int,
            float,
            bool,
            type(None),
            np.int_,
            np.int8,
            np.int16,
            np.int32,
            np.int64,
            np.float_,
            np.float16,
            np.float32,
            np.float64,
        ]
    )

    _allowed_builtins = {
        &#34;False&#34;: False,
        &#34;True&#34;: True,
        &#34;None&#34;: None,
    }

    # See https://docs.python.org/3/library/ast.html#abstract-grammar
    # We can add more functionalities by adding nodes
    _allowed_node_types = frozenset(
        [
            # Modules needed for parsing
            ast.Module,
            ast.Expr,
            # Allowed subclasses of ast.expr
            ast.BoolOp,
            ast.BinOp,
            ast.UnaryOp,
            ast.Compare,
            ast.Constant,
            ast.Name,
            # Allowed subclasses of ast.expr_context
            ast.Load,
            # Boolean operators
            ast.boolop,
            # Operators
            ast.operator,
            # Allowed sublclasses of ast.unaryop
            ast.Not,
            # Comparison operators
            ast.cmpop,
        ]
    )

    @staticmethod
    def validate_query(
        query_string: str,
        parser: str,
        force_parse: bool = True,
    ):
        &#34;&#34;&#34;
        Validates query for DataFrameFederatedLocal.query function.

        Parameters
        ----------
        query_string : str
            String to validate.
        parser : str
            Same as pd.DataFrame.query parser parameter.
        force_parse : bool = True
            str -&gt; AST -&gt; str parsing can make output code less optimize than the input (https://docs.python.org/3/library/ast.html#ast.unparse). However, for security purposes it&#39;s better to return a parsed string rather than just a validated string.
        Returns
        -------
        str
            The validated string.
        &#34;&#34;&#34;
        check_instance(query_string, str)
        check_instance(parser, str)
        check_instance(force_parse, bool)

        # Only an empty string query &#39;&#39; is evaluated here, it&#39;s just string manipulation to support special Pandas syntax (e.g. backticks (``))
        pandas_cleaned_string = Expr(&#34;&#39;&#39;&#34;, engine=&#34;numexpr&#34;, parser=parser, env=Scope(0))._visitor.preparser(
            query_string
        )

        # AST as generated and cleaned in Pandas but with Python builtin module
        query_ast = ast.fix_missing_locations(ast.parse(pandas_cleaned_string))

        # Now that we have the exact same AST as Pandas will have while evaluating our query,
        # we inspect it to make sure it doesn&#39;t contain anything we don&#39;t want
        # (More rigorous implementation with NodeVisitor subclass could potentially be usefull for implementing DP)
        expended_allowed_node_types = AstUtils.get_expended_allowed_node_types(Query._allowed_node_types)
        for node in ast.walk(query_ast):
            # Only allow allowed node types
            if type(node) not in expended_allowed_node_types:
                # Error message is vague on purpose for security reasons
                raise ValueError(&#34;Invalid query&#34;)

        if force_parse:
            unparse_buffer = io.StringIO()
            unparse.Unparser(query_ast, unparse_buffer)
            validated_query = unparse_buffer.getvalue()
        else:
            validated_query = pandas_cleaned_string

        return validated_query

    def _validate_envs(local_dict, global_dict) -&gt; frozenset([dict, dict]):
        &#34;&#34;&#34;
        Removes all unwanted variables of scope

        Parameters
        ----------
        local_dict : dict
            Original local_dict that will be filtered then given to pd.query
        global_dict : dict
            Original global_dict that will be filtered then given to pd.query

        Returns
        -------
        (local_dict : dict, global_dict : dict)
            local_dict :
                Safe local dict
            global_dict :
                Safe global dict
        &#34;&#34;&#34;
        safe_local_dict = {key: value for key, value in local_dict.items() if type(value) in Query._allowed_var_types}
        safe_global_dict = {key: value for key, value in global_dict.items() if type(value) in Query._allowed_var_types}
        # Without this, eval would be allowed to use all of builtins module (see https://docs.python.org/3/library/functions.html#eval)
        safe_local_dict[&#34;__builtins__&#34;] = Query._allowed_builtins
        safe_global_dict[&#34;__builtins__&#34;] = Query._allowed_builtins

        return safe_local_dict, safe_global_dict


class AstUtils:
    &#34;&#34;&#34;
    AST utils adapted from https://github.com/pandas-dev/pandas/blob/a6aaeb6baf679fe133e968e0f65199fc56d177b2/pandas/core/computation/expr.py#L180
    &#34;&#34;&#34;

    _all_nodes = frozenset(
        node
        for node in (getattr(ast, name) for name in dir(ast))
        if isinstance(node, type) and issubclass(node, ast.AST)
    )

    def _filter_nodes(superclass):
        &#34;&#34;&#34;
        Filter out AST nodes that are subclasses of ``superclass``.
        &#34;&#34;&#34;
        node_names = [node for node in AstUtils._all_nodes if issubclass(node, superclass)]
        return node_names

    # We have to do it this way instead of using issubclass directly on query nodes because
    # an attacker could make a custom child class of Ast.&lt;allowed_node&gt; which we don&#39;t want to allow
    def get_expended_allowed_node_types(allowed_node_types: frozenset) -&gt; frozenset:
        expended_allowed_node_types = []

        for node_type in Query._allowed_node_types:
            expended_allowed_node_types += AstUtils._filter_nodes(node_type)

        return frozenset(expended_allowed_node_types)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="sail_safe_functions.aggregator.preprocessing.query.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>data_frame_source: <a title="sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated" href="../data_frame_federated.html#sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated">DataFrameFederated</a>, query_expression: str, parser: str = 'pandas', local_dict: dict = None, global_dict: dict = None) ‑> <a title="sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated" href="../data_frame_federated.html#sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated">DataFrameFederated</a></span>
</code></dt>
<dd>
<div class="desc"><p>Federated equivalent of (pd.DataFrame.query)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(
    data_frame_source: DataFrameFederated,
    query_expression: str,
    parser: str = &#34;pandas&#34;,
    local_dict: dict = None,
    global_dict: dict = None,
) -&gt; DataFrameFederated:
    &#34;&#34;&#34;
    Federated equivalent of (pd.DataFrame.query)
    &#34;&#34;&#34;
    return Query.run(data_frame_source, query_expression, parser, local_dict, global_dict)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sail_safe_functions.aggregator.preprocessing.query.AstUtils"><code class="flex name class">
<span>class <span class="ident">AstUtils</span></span>
</code></dt>
<dd>
<div class="desc"><p>AST utils adapted from <a href="https://github.com/pandas-dev/pandas/blob/a6aaeb6baf679fe133e968e0f65199fc56d177b2/pandas/core/computation/expr.py#L180">https://github.com/pandas-dev/pandas/blob/a6aaeb6baf679fe133e968e0f65199fc56d177b2/pandas/core/computation/expr.py#L180</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AstUtils:
    &#34;&#34;&#34;
    AST utils adapted from https://github.com/pandas-dev/pandas/blob/a6aaeb6baf679fe133e968e0f65199fc56d177b2/pandas/core/computation/expr.py#L180
    &#34;&#34;&#34;

    _all_nodes = frozenset(
        node
        for node in (getattr(ast, name) for name in dir(ast))
        if isinstance(node, type) and issubclass(node, ast.AST)
    )

    def _filter_nodes(superclass):
        &#34;&#34;&#34;
        Filter out AST nodes that are subclasses of ``superclass``.
        &#34;&#34;&#34;
        node_names = [node for node in AstUtils._all_nodes if issubclass(node, superclass)]
        return node_names

    # We have to do it this way instead of using issubclass directly on query nodes because
    # an attacker could make a custom child class of Ast.&lt;allowed_node&gt; which we don&#39;t want to allow
    def get_expended_allowed_node_types(allowed_node_types: frozenset) -&gt; frozenset:
        expended_allowed_node_types = []

        for node_type in Query._allowed_node_types:
            expended_allowed_node_types += AstUtils._filter_nodes(node_type)

        return frozenset(expended_allowed_node_types)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="sail_safe_functions.aggregator.preprocessing.query.AstUtils.get_expended_allowed_node_types"><code class="name flex">
<span>def <span class="ident">get_expended_allowed_node_types</span></span>(<span>allowed_node_types: frozenset) ‑> frozenset</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_expended_allowed_node_types(allowed_node_types: frozenset) -&gt; frozenset:
    expended_allowed_node_types = []

    for node_type in Query._allowed_node_types:
        expended_allowed_node_types += AstUtils._filter_nodes(node_type)

    return frozenset(expended_allowed_node_types)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sail_safe_functions.aggregator.preprocessing.query.Query"><code class="flex name class">
<span>class <span class="ident">Query</span></span>
</code></dt>
<dd>
<div class="desc"><p>Federated equivalent of (pd.DataFrame.query)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Query:
    &#34;&#34;&#34;
    Federated equivalent of (pd.DataFrame.query)
    &#34;&#34;&#34;

    @staticmethod
    def run(
        data_frame_source: DataFrameFederated,
        query_expression: str,
        parser: str,
        local_dict: dict,
        global_dict: dict,
    ) -&gt; DataFrameFederated:
        &#34;&#34;&#34;
        Perform federated query (pandas.DataFrame.query) function

        :param data_frame_source: The target DataFrame
        :type data_frame_source: DataFrameFederated
        :param query_expression: The query string to evaluate. You can refer to variables in the environment by prefixing them with an ‘@’ character like @a + b. You can refer to column names that are not valid Python variable names by surrounding them in backticks. Thus, column names containing spaces or punctuations (besides underscores) or starting with digits must be surrounded by backticks. (For example, a column named “Area (cm^2)” would be referenced as `Area (cm^2)`). Column names which are Python keywords (like “list”, “for”, “import”, etc) cannot be used. For example, if one of your columns is called a a and you want to sum it with b, your query should be `a a` + b.
        :type query_expression: str
        :param parser: The parser to use to construct the syntax tree from the expression. The default of &#39;pandas&#39; parses code slightly different than standard Python. Alternatively, you can parse an expression using the &#39;python&#39; parser to retain strict Python semantics. See the https://pandas.pydata.org/docs/user_guide/enhancingperf.html#enhancingperf-eval documentation for more details.
        :type parser: str
        :param local_dict: A dictionary of local variables, taken from locals() by default.
        :type local_dict: dict
        :param global_dict: A dictionary of global variables, taken from globals() by default.
        :type global_dict: dict
        :return: Federated DataFrame resulting from the provided query expression.
        :rtype: DataFrameFederated
        &#34;&#34;&#34;
        check_instance(data_frame_source, DataFrameFederated)
        check_instance(query_expression, str)
        check_instance(parser, str)
        check_instance(local_dict, (dict, type(None)))
        check_instance(global_dict, (dict, type(None)))

        caller_frame = sys._getframe(2)
        local_dict = local_dict if local_dict else caller_frame.f_locals
        global_dict = global_dict if global_dict else caller_frame.f_globals

        validated_query = Query.validate_query(
            query_expression,
            parser,
        )
        validated_local_dict, validated_global_dict = Query._validate_envs(local_dict, global_dict)

        list_reference = data_frame_source.map_function(
            QueryPrecompute,
            validated_query,
            parser,
            validated_local_dict,
            validated_global_dict,
        )

        return DataFrameFederated(list_reference, data_frame_source.data_model_data_frame)

    # Target dataframe will be allowed even if pd.DataFrame is not included here
    _allowed_var_types = frozenset(
        [
            str,
            int,
            float,
            bool,
            type(None),
            np.int_,
            np.int8,
            np.int16,
            np.int32,
            np.int64,
            np.float_,
            np.float16,
            np.float32,
            np.float64,
        ]
    )

    _allowed_builtins = {
        &#34;False&#34;: False,
        &#34;True&#34;: True,
        &#34;None&#34;: None,
    }

    # See https://docs.python.org/3/library/ast.html#abstract-grammar
    # We can add more functionalities by adding nodes
    _allowed_node_types = frozenset(
        [
            # Modules needed for parsing
            ast.Module,
            ast.Expr,
            # Allowed subclasses of ast.expr
            ast.BoolOp,
            ast.BinOp,
            ast.UnaryOp,
            ast.Compare,
            ast.Constant,
            ast.Name,
            # Allowed subclasses of ast.expr_context
            ast.Load,
            # Boolean operators
            ast.boolop,
            # Operators
            ast.operator,
            # Allowed sublclasses of ast.unaryop
            ast.Not,
            # Comparison operators
            ast.cmpop,
        ]
    )

    @staticmethod
    def validate_query(
        query_string: str,
        parser: str,
        force_parse: bool = True,
    ):
        &#34;&#34;&#34;
        Validates query for DataFrameFederatedLocal.query function.

        Parameters
        ----------
        query_string : str
            String to validate.
        parser : str
            Same as pd.DataFrame.query parser parameter.
        force_parse : bool = True
            str -&gt; AST -&gt; str parsing can make output code less optimize than the input (https://docs.python.org/3/library/ast.html#ast.unparse). However, for security purposes it&#39;s better to return a parsed string rather than just a validated string.
        Returns
        -------
        str
            The validated string.
        &#34;&#34;&#34;
        check_instance(query_string, str)
        check_instance(parser, str)
        check_instance(force_parse, bool)

        # Only an empty string query &#39;&#39; is evaluated here, it&#39;s just string manipulation to support special Pandas syntax (e.g. backticks (``))
        pandas_cleaned_string = Expr(&#34;&#39;&#39;&#34;, engine=&#34;numexpr&#34;, parser=parser, env=Scope(0))._visitor.preparser(
            query_string
        )

        # AST as generated and cleaned in Pandas but with Python builtin module
        query_ast = ast.fix_missing_locations(ast.parse(pandas_cleaned_string))

        # Now that we have the exact same AST as Pandas will have while evaluating our query,
        # we inspect it to make sure it doesn&#39;t contain anything we don&#39;t want
        # (More rigorous implementation with NodeVisitor subclass could potentially be usefull for implementing DP)
        expended_allowed_node_types = AstUtils.get_expended_allowed_node_types(Query._allowed_node_types)
        for node in ast.walk(query_ast):
            # Only allow allowed node types
            if type(node) not in expended_allowed_node_types:
                # Error message is vague on purpose for security reasons
                raise ValueError(&#34;Invalid query&#34;)

        if force_parse:
            unparse_buffer = io.StringIO()
            unparse.Unparser(query_ast, unparse_buffer)
            validated_query = unparse_buffer.getvalue()
        else:
            validated_query = pandas_cleaned_string

        return validated_query

    def _validate_envs(local_dict, global_dict) -&gt; frozenset([dict, dict]):
        &#34;&#34;&#34;
        Removes all unwanted variables of scope

        Parameters
        ----------
        local_dict : dict
            Original local_dict that will be filtered then given to pd.query
        global_dict : dict
            Original global_dict that will be filtered then given to pd.query

        Returns
        -------
        (local_dict : dict, global_dict : dict)
            local_dict :
                Safe local dict
            global_dict :
                Safe global dict
        &#34;&#34;&#34;
        safe_local_dict = {key: value for key, value in local_dict.items() if type(value) in Query._allowed_var_types}
        safe_global_dict = {key: value for key, value in global_dict.items() if type(value) in Query._allowed_var_types}
        # Without this, eval would be allowed to use all of builtins module (see https://docs.python.org/3/library/functions.html#eval)
        safe_local_dict[&#34;__builtins__&#34;] = Query._allowed_builtins
        safe_global_dict[&#34;__builtins__&#34;] = Query._allowed_builtins

        return safe_local_dict, safe_global_dict</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sail_safe_functions.aggregator.preprocessing.query.Query.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>data_frame_source: <a title="sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated" href="../data_frame_federated.html#sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated">DataFrameFederated</a>, query_expression: str, parser: str, local_dict: dict, global_dict: dict) ‑> <a title="sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated" href="../data_frame_federated.html#sail_safe_functions.aggregator.data_frame_federated.DataFrameFederated">DataFrameFederated</a></span>
</code></dt>
<dd>
<div class="desc"><p>Perform federated query (pandas.DataFrame.query) function</p>
<p>:param data_frame_source: The target DataFrame
:type data_frame_source: DataFrameFederated
:param query_expression: The query string to evaluate. You can refer to variables in the environment by prefixing them with an ‘@’ character like @a + b. You can refer to column names that are not valid Python variable names by surrounding them in backticks. Thus, column names containing spaces or punctuations (besides underscores) or starting with digits must be surrounded by backticks. (For example, a column named “Area (cm^2)” would be referenced as <code>Area (cm^2)</code>). Column names which are Python keywords (like “list”, “for”, “import”, etc) cannot be used. For example, if one of your columns is called a a and you want to sum it with b, your query should be <code>a a</code> + b.
:type query_expression: str
:param parser: The parser to use to construct the syntax tree from the expression. The default of 'pandas' parses code slightly different than standard Python. Alternatively, you can parse an expression using the 'python' parser to retain strict Python semantics. See the <a href="https://pandas.pydata.org/docs/user_guide/enhancingperf.html#enhancingperf-eval">https://pandas.pydata.org/docs/user_guide/enhancingperf.html#enhancingperf-eval</a> documentation for more details.
:type parser: str
:param local_dict: A dictionary of local variables, taken from locals() by default.
:type local_dict: dict
:param global_dict: A dictionary of global variables, taken from globals() by default.
:type global_dict: dict
:return: Federated DataFrame resulting from the provided query expression.
:rtype: DataFrameFederated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def run(
    data_frame_source: DataFrameFederated,
    query_expression: str,
    parser: str,
    local_dict: dict,
    global_dict: dict,
) -&gt; DataFrameFederated:
    &#34;&#34;&#34;
    Perform federated query (pandas.DataFrame.query) function

    :param data_frame_source: The target DataFrame
    :type data_frame_source: DataFrameFederated
    :param query_expression: The query string to evaluate. You can refer to variables in the environment by prefixing them with an ‘@’ character like @a + b. You can refer to column names that are not valid Python variable names by surrounding them in backticks. Thus, column names containing spaces or punctuations (besides underscores) or starting with digits must be surrounded by backticks. (For example, a column named “Area (cm^2)” would be referenced as `Area (cm^2)`). Column names which are Python keywords (like “list”, “for”, “import”, etc) cannot be used. For example, if one of your columns is called a a and you want to sum it with b, your query should be `a a` + b.
    :type query_expression: str
    :param parser: The parser to use to construct the syntax tree from the expression. The default of &#39;pandas&#39; parses code slightly different than standard Python. Alternatively, you can parse an expression using the &#39;python&#39; parser to retain strict Python semantics. See the https://pandas.pydata.org/docs/user_guide/enhancingperf.html#enhancingperf-eval documentation for more details.
    :type parser: str
    :param local_dict: A dictionary of local variables, taken from locals() by default.
    :type local_dict: dict
    :param global_dict: A dictionary of global variables, taken from globals() by default.
    :type global_dict: dict
    :return: Federated DataFrame resulting from the provided query expression.
    :rtype: DataFrameFederated
    &#34;&#34;&#34;
    check_instance(data_frame_source, DataFrameFederated)
    check_instance(query_expression, str)
    check_instance(parser, str)
    check_instance(local_dict, (dict, type(None)))
    check_instance(global_dict, (dict, type(None)))

    caller_frame = sys._getframe(2)
    local_dict = local_dict if local_dict else caller_frame.f_locals
    global_dict = global_dict if global_dict else caller_frame.f_globals

    validated_query = Query.validate_query(
        query_expression,
        parser,
    )
    validated_local_dict, validated_global_dict = Query._validate_envs(local_dict, global_dict)

    list_reference = data_frame_source.map_function(
        QueryPrecompute,
        validated_query,
        parser,
        validated_local_dict,
        validated_global_dict,
    )

    return DataFrameFederated(list_reference, data_frame_source.data_model_data_frame)</code></pre>
</details>
</dd>
<dt id="sail_safe_functions.aggregator.preprocessing.query.Query.validate_query"><code class="name flex">
<span>def <span class="ident">validate_query</span></span>(<span>query_string: str, parser: str, force_parse: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Validates query for DataFrameFederatedLocal.query function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>query_string</code></strong> :&ensp;<code>str</code></dt>
<dd>String to validate.</dd>
<dt><strong><code>parser</code></strong> :&ensp;<code>str</code></dt>
<dd>Same as pd.DataFrame.query parser parameter.</dd>
<dt><strong><code>force_parse</code></strong> :&ensp;<code>bool = True</code></dt>
<dd>str -&gt; AST -&gt; str parsing can make output code less optimize than the input (<a href="https://docs.python.org/3/library/ast.html#ast.unparse">https://docs.python.org/3/library/ast.html#ast.unparse</a>). However, for security purposes it's better to return a parsed string rather than just a validated string.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>The validated string.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def validate_query(
    query_string: str,
    parser: str,
    force_parse: bool = True,
):
    &#34;&#34;&#34;
    Validates query for DataFrameFederatedLocal.query function.

    Parameters
    ----------
    query_string : str
        String to validate.
    parser : str
        Same as pd.DataFrame.query parser parameter.
    force_parse : bool = True
        str -&gt; AST -&gt; str parsing can make output code less optimize than the input (https://docs.python.org/3/library/ast.html#ast.unparse). However, for security purposes it&#39;s better to return a parsed string rather than just a validated string.
    Returns
    -------
    str
        The validated string.
    &#34;&#34;&#34;
    check_instance(query_string, str)
    check_instance(parser, str)
    check_instance(force_parse, bool)

    # Only an empty string query &#39;&#39; is evaluated here, it&#39;s just string manipulation to support special Pandas syntax (e.g. backticks (``))
    pandas_cleaned_string = Expr(&#34;&#39;&#39;&#34;, engine=&#34;numexpr&#34;, parser=parser, env=Scope(0))._visitor.preparser(
        query_string
    )

    # AST as generated and cleaned in Pandas but with Python builtin module
    query_ast = ast.fix_missing_locations(ast.parse(pandas_cleaned_string))

    # Now that we have the exact same AST as Pandas will have while evaluating our query,
    # we inspect it to make sure it doesn&#39;t contain anything we don&#39;t want
    # (More rigorous implementation with NodeVisitor subclass could potentially be usefull for implementing DP)
    expended_allowed_node_types = AstUtils.get_expended_allowed_node_types(Query._allowed_node_types)
    for node in ast.walk(query_ast):
        # Only allow allowed node types
        if type(node) not in expended_allowed_node_types:
            # Error message is vague on purpose for security reasons
            raise ValueError(&#34;Invalid query&#34;)

    if force_parse:
        unparse_buffer = io.StringIO()
        unparse.Unparser(query_ast, unparse_buffer)
        validated_query = unparse_buffer.getvalue()
    else:
        validated_query = pandas_cleaned_string

    return validated_query</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sail_safe_functions.aggregator.preprocessing" href="index.html">sail_safe_functions.aggregator.preprocessing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="sail_safe_functions.aggregator.preprocessing.query.query" href="#sail_safe_functions.aggregator.preprocessing.query.query">query</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sail_safe_functions.aggregator.preprocessing.query.AstUtils" href="#sail_safe_functions.aggregator.preprocessing.query.AstUtils">AstUtils</a></code></h4>
<ul class="">
<li><code><a title="sail_safe_functions.aggregator.preprocessing.query.AstUtils.get_expended_allowed_node_types" href="#sail_safe_functions.aggregator.preprocessing.query.AstUtils.get_expended_allowed_node_types">get_expended_allowed_node_types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sail_safe_functions.aggregator.preprocessing.query.Query" href="#sail_safe_functions.aggregator.preprocessing.query.Query">Query</a></code></h4>
<ul class="">
<li><code><a title="sail_safe_functions.aggregator.preprocessing.query.Query.run" href="#sail_safe_functions.aggregator.preprocessing.query.Query.run">run</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.preprocessing.query.Query.validate_query" href="#sail_safe_functions.aggregator.preprocessing.query.Query.validate_query">validate_query</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>