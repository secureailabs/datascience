<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>sail_safe_functions.aggregator.series API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sail_safe_functions.aggregator.series</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import List

from pandas import Series as SeriesPandas
from sail_safe_functions.aggregator.data_model.data_model_series import DataModelSeries


class Series(SeriesPandas):
    # NOTE Long term this overloading trick is not maintainable and we will need to create a
    # class where the pandas object in a member not a superclass
    # TODO Put the datamodel last because we do that everwhere else
    def __init__(self, dataset_id: str, data_model_series: DataModelSeries, list_data: List) -&gt; None:
        super().__init__(data=list_data, name=data_model_series.series_name)
        # TODO trying to avoid circular import here solution would be to move the reference but that is invasive
        if not isinstance(dataset_id, str):
            raise Exception(f&#34;{dataset_id} is not instance of class: {str} instead type is {type(dataset_id)}&#34;)
        if not isinstance(data_model_series, DataModelSeries):
            raise Exception(
                f&#34;{data_model_series} is not instance of class: {DataModelSeries} instead type is {type(data_model_series)}&#34;
            )
        self._dataset_id = dataset_id
        self._data_model_series = data_model_series

    @property
    def series_name(self) -&gt; str:
        return self._data_model_series.series_name

    @property
    def dataset_id(self) -&gt; str:
        return self._dataset_id

    @property
    def data_model_series(self) -&gt; DataModelSeries:
        return self._data_model_series

    @staticmethod
    def from_pandas(
        dataset_id: str,
        data_model_series: DataModelSeries,
        series_pandas: SeriesPandas,
    ) -&gt; &#34;Series&#34;:
        if series_pandas.dtype == int:
            # dtype is aways float no ints allowed at this point
            series_pandas = series_pandas.astype(float)
        series = Series(dataset_id, data_model_series, series_pandas.to_list())
        series.index = series_pandas.index
        return series

    # TODO check what feature we use on the Pandas series that return pandas series, those will need overloading</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sail_safe_functions.aggregator.series.Series"><code class="flex name class">
<span>class <span class="ident">Series</span></span>
<span>(</span><span>dataset_id: str, data_model_series: <a title="sail_safe_functions.aggregator.data_model.data_model_series.DataModelSeries" href="data_model/data_model_series.html#sail_safe_functions.aggregator.data_model.data_model_series.DataModelSeries">DataModelSeries</a>, list_data: List[~T])</span>
</code></dt>
<dd>
<div class="desc"><p>One-dimensional ndarray with axis labels (including time series).</p>
<p>Labels need not be unique but must be a hashable type. The object
supports both integer- and label-based indexing and provides a host of
methods for performing operations involving the index. Statistical
methods from ndarray have been overridden to automatically exclude
missing data (currently represented as NaN).</p>
<p>Operations between Series (+, -, /, *, **) align values based on their
associated index values&ndash; they need not be the same length. The result
index will be the sorted union of the two indexes.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array-like, Iterable, dict,</code> or <code>scalar value</code></dt>
<dd>Contains data stored in Series. If data is a dict, argument order is
maintained.</dd>
<dt><strong><code>index</code></strong> :&ensp;<code>array-like</code> or <code>Index (1d)</code></dt>
<dd>Values must be hashable and have the same length as <code>data</code>.
Non-unique index values are allowed. Will default to
RangeIndex (0, 1, 2, &hellip;, n) if not provided. If data is dict-like
and index is None, then the keys in the data are used as the index. If the
index is not None, the resulting Series is reindexed with the index values.</dd>
<dt><strong><code>dtype</code></strong> :&ensp;<code>str, numpy.dtype,</code> or <code>ExtensionDtype</code>, optional</dt>
<dd>Data type for the output Series. If not specified, this will be
inferred from <code>data</code>.
See the :ref:<code>user guide &lt;basics.dtypes&gt;</code> for more usages.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The name to give to the Series.</dd>
<dt><strong><code>copy</code></strong> :&ensp;<code>bool</code>, default <code>False</code></dt>
<dd>Copy input data. Only affects Series or 1d ndarray input. See examples.</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>Constructing Series from a dictionary with an Index specified</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; ser = pd.Series(data=d, index=['a', 'b', 'c'])
&gt;&gt;&gt; ser
a   1
b   2
c   3
dtype: int64
</code></pre>
<p>The keys of the dictionary match with the Index values, hence the Index
values have no effect.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; d = {'a': 1, 'b': 2, 'c': 3}
&gt;&gt;&gt; ser = pd.Series(data=d, index=['x', 'y', 'z'])
&gt;&gt;&gt; ser
x   NaN
y   NaN
z   NaN
dtype: float64
</code></pre>
<p>Note that the Index is first build with the keys from the dictionary.
After this the Series is reindexed with the given Index values, hence we
get all NaN as a result.</p>
<p>Constructing Series from a list with <code>copy=False</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; r = [1, 2]
&gt;&gt;&gt; ser = pd.Series(r, copy=False)
&gt;&gt;&gt; ser.iloc[0] = 999
&gt;&gt;&gt; r
[1, 2]
&gt;&gt;&gt; ser
0    999
1      2
dtype: int64
</code></pre>
<p>Due to input data type the Series has a <code>copy</code> of
the original data even though <code>copy=False</code>, so
the data is unchanged.</p>
<p>Constructing Series from a 1d ndarray with <code>copy=False</code>.</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; r = np.array([1, 2])
&gt;&gt;&gt; ser = pd.Series(r, copy=False)
&gt;&gt;&gt; ser.iloc[0] = 999
&gt;&gt;&gt; r
array([999,   2])
&gt;&gt;&gt; ser
0    999
1      2
dtype: int64
</code></pre>
<p>Due to input data type the Series has a <code>view</code> on
the original data, so
the data is changed as well.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Series(SeriesPandas):
    # NOTE Long term this overloading trick is not maintainable and we will need to create a
    # class where the pandas object in a member not a superclass
    # TODO Put the datamodel last because we do that everwhere else
    def __init__(self, dataset_id: str, data_model_series: DataModelSeries, list_data: List) -&gt; None:
        super().__init__(data=list_data, name=data_model_series.series_name)
        # TODO trying to avoid circular import here solution would be to move the reference but that is invasive
        if not isinstance(dataset_id, str):
            raise Exception(f&#34;{dataset_id} is not instance of class: {str} instead type is {type(dataset_id)}&#34;)
        if not isinstance(data_model_series, DataModelSeries):
            raise Exception(
                f&#34;{data_model_series} is not instance of class: {DataModelSeries} instead type is {type(data_model_series)}&#34;
            )
        self._dataset_id = dataset_id
        self._data_model_series = data_model_series

    @property
    def series_name(self) -&gt; str:
        return self._data_model_series.series_name

    @property
    def dataset_id(self) -&gt; str:
        return self._dataset_id

    @property
    def data_model_series(self) -&gt; DataModelSeries:
        return self._data_model_series

    @staticmethod
    def from_pandas(
        dataset_id: str,
        data_model_series: DataModelSeries,
        series_pandas: SeriesPandas,
    ) -&gt; &#34;Series&#34;:
        if series_pandas.dtype == int:
            # dtype is aways float no ints allowed at this point
            series_pandas = series_pandas.astype(float)
        series = Series(dataset_id, data_model_series, series_pandas.to_list())
        series.index = series_pandas.index
        return series

    # TODO check what feature we use on the Pandas series that return pandas series, those will need overloading</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pandas.core.series.Series</li>
<li>pandas.core.base.IndexOpsMixin</li>
<li>pandas.core.arraylike.OpsMixin</li>
<li>pandas.core.generic.NDFrame</li>
<li>pandas.core.base.PandasObject</li>
<li>pandas.core.accessor.DirNamesMixin</li>
<li>pandas.core.indexing.IndexingMixin</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="sail_safe_functions.aggregator.series.Series.from_pandas"><code class="name flex">
<span>def <span class="ident">from_pandas</span></span>(<span>dataset_id: str, data_model_series: <a title="sail_safe_functions.aggregator.data_model.data_model_series.DataModelSeries" href="data_model/data_model_series.html#sail_safe_functions.aggregator.data_model.data_model_series.DataModelSeries">DataModelSeries</a>, series_pandas: pandas.core.series.Series) ‑> <a title="sail_safe_functions.aggregator.series.Series" href="#sail_safe_functions.aggregator.series.Series">Series</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_pandas(
    dataset_id: str,
    data_model_series: DataModelSeries,
    series_pandas: SeriesPandas,
) -&gt; &#34;Series&#34;:
    if series_pandas.dtype == int:
        # dtype is aways float no ints allowed at this point
        series_pandas = series_pandas.astype(float)
    series = Series(dataset_id, data_model_series, series_pandas.to_list())
    series.index = series_pandas.index
    return series</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="sail_safe_functions.aggregator.series.Series.data_model_series"><code class="name">var <span class="ident">data_model_series</span> : <a title="sail_safe_functions.aggregator.data_model.data_model_series.DataModelSeries" href="data_model/data_model_series.html#sail_safe_functions.aggregator.data_model.data_model_series.DataModelSeries">DataModelSeries</a></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def data_model_series(self) -&gt; DataModelSeries:
    return self._data_model_series</code></pre>
</details>
</dd>
<dt id="sail_safe_functions.aggregator.series.Series.dataset_id"><code class="name">var <span class="ident">dataset_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dataset_id(self) -&gt; str:
    return self._dataset_id</code></pre>
</details>
</dd>
<dt id="sail_safe_functions.aggregator.series.Series.index"><code class="name">var <span class="ident">index</span></code></dt>
<dd>
<div class="desc"><p>The index (axis labels) of the Series.</p></div>
</dd>
<dt id="sail_safe_functions.aggregator.series.Series.series_name"><code class="name">var <span class="ident">series_name</span> : str</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def series_name(self) -&gt; str:
    return self._data_model_series.series_name</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sail_safe_functions.aggregator.series.Series.div"><code class="name flex">
<span>def <span class="ident">div</span></span>(<span>self, other, level=None, fill_value=None, axis=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return Floating division of series and other, element-wise (binary operator <code>truediv</code>).</p>
<p>Equivalent to <code>series / other</code>, but with support to substitute a fill_value for
missing data in either one of the inputs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="sail_safe_functions.aggregator.series.Series" href="#sail_safe_functions.aggregator.series.Series">Series</a></code> or <code>scalar value</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>None</code> or <code>float value</code>, default <code>None (NaN)</code></dt>
<dd>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result of filling (at that location) will be missing.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code> or <code>name</code></dt>
<dd>Broadcast across a level, matching Index values on the
passed MultiIndex level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sail_safe_functions.aggregator.series.Series" href="#sail_safe_functions.aggregator.series.Series">Series</a></code></dt>
<dd>The result of the operation.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Series.rtruediv</code></dt>
<dd>Reverse of the Floating division operator, see <code>Python documentation &lt;https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types&gt;</code>_ for more details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; a = pd.Series([1, 1, 1, np.nan], index=['a', 'b', 'c', 'd'])
&gt;&gt;&gt; a
a    1.0
b    1.0
c    1.0
d    NaN
dtype: float64
&gt;&gt;&gt; b = pd.Series([1, np.nan, 1, np.nan], index=['a', 'b', 'd', 'e'])
&gt;&gt;&gt; b
a    1.0
b    NaN
d    1.0
e    NaN
dtype: float64
&gt;&gt;&gt; a.divide(b, fill_value=0)
a    1.0
b    inf
c    inf
d    0.0
e    NaN
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@Appender(doc)
def flex_wrapper(self, other, level=None, fill_value=None, axis=0):
    # validate axis
    if axis is not None:
        self._get_axis_number(axis)

    res_name = get_op_result_name(self, other)

    if isinstance(other, ABCSeries):
        return self._binop(other, op, level=level, fill_value=fill_value)
    elif isinstance(other, (np.ndarray, list, tuple)):
        if len(other) != len(self):
            raise ValueError(&#34;Lengths must be equal&#34;)
        other = self._constructor(other, self.index)
        result = self._binop(other, op, level=level, fill_value=fill_value)
        result.name = res_name
        return result
    else:
        if fill_value is not None:
            self = self.fillna(fill_value)

        return op(self, other)</code></pre>
</details>
</dd>
<dt id="sail_safe_functions.aggregator.series.Series.rdiv"><code class="name flex">
<span>def <span class="ident">rdiv</span></span>(<span>self, other, level=None, fill_value=None, axis=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return Floating division of series and other, element-wise (binary operator <code>rtruediv</code>).</p>
<p>Equivalent to <code>other / series</code>, but with support to substitute a fill_value for
missing data in either one of the inputs.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code><a title="sail_safe_functions.aggregator.series.Series" href="#sail_safe_functions.aggregator.series.Series">Series</a></code> or <code>scalar value</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fill_value</code></strong> :&ensp;<code>None</code> or <code>float value</code>, default <code>None (NaN)</code></dt>
<dd>Fill existing missing (NaN) values, and any new element needed for
successful Series alignment, with this value before computation.
If data in both corresponding Series locations is missing
the result of filling (at that location) will be missing.</dd>
<dt><strong><code>level</code></strong> :&ensp;<code>int</code> or <code>name</code></dt>
<dd>Broadcast across a level, matching Index values on the
passed MultiIndex level.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="sail_safe_functions.aggregator.series.Series" href="#sail_safe_functions.aggregator.series.Series">Series</a></code></dt>
<dd>The result of the operation.</dd>
</dl>
<h2 id="see-also">See Also</h2>
<dl>
<dt><code>Series.truediv</code></dt>
<dd>Element-wise Floating division, see <code>Python documentation &lt;https://docs.python.org/3/reference/datamodel.html#emulating-numeric-types&gt;</code>_ for more details.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; a = pd.Series([1, 1, 1, np.nan], index=['a', 'b', 'c', 'd'])
&gt;&gt;&gt; a
a    1.0
b    1.0
c    1.0
d    NaN
dtype: float64
&gt;&gt;&gt; b = pd.Series([1, np.nan, 1, np.nan], index=['a', 'b', 'd', 'e'])
&gt;&gt;&gt; b
a    1.0
b    NaN
d    1.0
e    NaN
dtype: float64
&gt;&gt;&gt; a.divide(b, fill_value=0)
a    1.0
b    inf
c    inf
d    0.0
e    NaN
dtype: float64
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@Appender(doc)
def flex_wrapper(self, other, level=None, fill_value=None, axis=0):
    # validate axis
    if axis is not None:
        self._get_axis_number(axis)

    res_name = get_op_result_name(self, other)

    if isinstance(other, ABCSeries):
        return self._binop(other, op, level=level, fill_value=fill_value)
    elif isinstance(other, (np.ndarray, list, tuple)):
        if len(other) != len(self):
            raise ValueError(&#34;Lengths must be equal&#34;)
        other = self._constructor(other, self.index)
        result = self._binop(other, op, level=level, fill_value=fill_value)
        result.name = res_name
        return result
    else:
        if fill_value is not None:
            self = self.fillna(fill_value)

        return op(self, other)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sail_safe_functions.aggregator" href="index.html">sail_safe_functions.aggregator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sail_safe_functions.aggregator.series.Series" href="#sail_safe_functions.aggregator.series.Series">Series</a></code></h4>
<ul class="two-column">
<li><code><a title="sail_safe_functions.aggregator.series.Series.data_model_series" href="#sail_safe_functions.aggregator.series.Series.data_model_series">data_model_series</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.series.Series.dataset_id" href="#sail_safe_functions.aggregator.series.Series.dataset_id">dataset_id</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.series.Series.div" href="#sail_safe_functions.aggregator.series.Series.div">div</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.series.Series.from_pandas" href="#sail_safe_functions.aggregator.series.Series.from_pandas">from_pandas</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.series.Series.index" href="#sail_safe_functions.aggregator.series.Series.index">index</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.series.Series.rdiv" href="#sail_safe_functions.aggregator.series.Series.rdiv">rdiv</a></code></li>
<li><code><a title="sail_safe_functions.aggregator.series.Series.series_name" href="#sail_safe_functions.aggregator.series.Series.series_name">series_name</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>